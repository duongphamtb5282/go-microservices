# Google Wire Dependency Injection Guide

## Table of Contents

1. [Overview](#overview)
2. [What is Google Wire?](#what-is-google-wire)
3. [Setup and Installation](#setup-and-installation)
4. [Project Structure](#project-structure)
5. [Understanding Wire Concepts](#understanding-wire-concepts)
6. [How to Use Wire in Auth-Service](#how-to-use-wire-in-auth-service)
7. [Creating Providers](#creating-providers)
8. [Compiling Wire](#compiling-wire)
9. [Troubleshooting](#troubleshooting)
10. [Best Practices](#best-practices)

---

## Overview

This guide explains how to use Google Wire for dependency injection in the `auth-service` project. Wire is a code generation tool that automates connecting components using dependency injection.

**Current Status**: The project has Wire configured but is currently using manual dependency injection via `ServiceFactory`. This guide shows how to use Wire as an alternative approach.

---

## What is Google Wire?

**Google Wire** is a compile-time dependency injection tool for Go. Unlike runtime DI frameworks, Wire generates readable Go code that:

- ✅ **Compile-time safety**: Catches missing dependencies at compile time, not runtime
- ✅ **No reflection**: Generated code is plain Go with no magic
- ✅ **Easy debugging**: Generated code is readable and can be debugged
- ✅ **No runtime overhead**: Zero performance cost compared to manual DI
- ✅ **Explicit**: Dependencies are clear and traceable

### Wire vs Manual DI

| Aspect          | Manual DI (ServiceFactory)         | Google Wire                      |
| --------------- | ---------------------------------- | -------------------------------- |
| Setup           | Manual wiring in code              | Automatic code generation        |
| Type safety     | Compile-time                       | Compile-time                     |
| Maintainability | Requires updating factory manually | Auto-updates on provider changes |
| Debugging       | Direct debugging                   | Debug generated code             |
| Learning curve  | Low                                | Medium                           |

---

## Setup and Installation

### 1. Install Wire CLI

```bash
go install github.com/google/wire/cmd/wire@latest
```

Verify installation:

```bash
wire version
# Output: wire: v0.7.0 or later
```

### 2. Add Wire to go.mod

Wire is already in `go.mod`:

```go
require (
    github.com/google/wire v0.7.0
)
```

If not present, add it:

```bash
go get github.com/google/wire/cmd/wire
```

### 3. Verify Installation

```bash
which wire
# Output: /Users/your-username/go/bin/wire (or similar)
```

If `wire` is not in PATH, add `$GOPATH/bin` to your PATH:

```bash
export PATH=$PATH:$(go env GOPATH)/bin
```

---

## Project Structure

The Wire configuration in `auth-service` follows this structure:

```
auth-service/
├── src/
│   ├── applications/
│   │   ├── wire.go           # Wire definitions (input)
│   │   ├── wire_gen.go       # Generated code (output, git-ignored)
│   │   ├── service_factory.go # Manual DI (alternative)
│   │   └── providers/
│   │       ├── repository_providers.go
│   │       ├── service_providers.go
│   │       ├── handler_providers.go
│   │       └── middleware_providers.go
```

**Key Files**:

- **`wire.go`**: Contains Wire injector definitions (what you want to build)
- **`wire_gen.go`**: Auto-generated by Wire (never edit manually)
- **`providers/*`**: Provider functions that create dependencies

---

## Understanding Wire Concepts

### 1. Providers

A **provider** is a function that creates a dependency:

```go
// Provider function
func UserRepositoryProvider(db database.Database, logger *logging.Logger) repositories.UserRepository {
    return postgres.NewPostgresUserRepository(db, logger)
}
```

### 2. Injectors

An **injector** is a function that Wire will implement for you:

```go
//go:build wireinject

func InitializeAuthService(
    cfg *config.Config,
    db database.Database,
    logger *logging.Logger,
) *gin.Engine {
    wire.Build(
        // List all providers
        UserRepositoryProvider,
        UserServiceProvider,
        // ...
    )
    return &gin.Engine{} // Placeholder, Wire replaces this
}
```

### 3. Provider Sets

Group related providers together:

```go
var RepositoryProviderSet = wire.NewSet(
    UserRepositoryProvider,
    RoleRepositoryProvider,
    PermissionRepositoryProvider,
)
```

### 4. Build Tags

Wire files must have the `wireinject` build tag:

```go
//go:build wireinject
// +build wireinject
```

This prevents the file from being compiled normally (only Wire processes it).

---

## How to Use Wire in Auth-Service

### Current Wire Configuration

The project has a Wire injector defined in `src/applications/wire.go`:

```go
//go:build wireinject
// +build wireinject

package applications

import (
    "auth-service/src/applications/providers"
    "github.com/google/wire"
    "github.com/gin-gonic/gin"
)

func InitializeAuthService(
    cfg *config.Config,
    db database.Database,
    brokers []string,
    logger *logging.Logger,
) *gin.Engine {
    wire.Build(
        // Provider functions
        providers.UserRepositoryProvider,
        providers.UserCacheProvider,
        providers.UserDomainServiceProvider,
        providers.EventBusProvider,
        providers.UserApplicationServiceProvider,
        providers.UserHandlerProvider,
        providers.AuthHandlerProvider,
        providers.MiddlewareSetupProvider,
        providers.RouterProvider,

        // Custom setup
        setupRouter,
    )
    return &gin.Engine{} // Wire replaces this
}

func setupRouter(
    router *router.Router,
    middlewareSetup *middleware.MiddlewareSetup,
) *gin.Engine {
    ginRouter := router.SetupRoutes()
    middlewareSetup.SetupMiddleware(ginRouter)
    return ginRouter
}
```

### Provider Example

Here's how providers are structured in `src/applications/providers/`:

```go
package providers

import (
    "auth-service/src/applications/services"
    "auth-service/src/domain/repositories"
    "backend-core/logging"
)

// UserApplicationServiceProvider creates a user application service
func UserApplicationServiceProvider(
    userRepo repositories.UserRepository,
    userCache repositories.UserCache,
    logger *logging.Logger,
    telemetry *telemetry.SimpleTelemetry,
    metrics *telemetry.BusinessMetrics,
) *services.UserApplicationService {
    return services.NewUserApplicationService(
        userRepo,
        userCache,
        logger,
        telemetry,
        metrics,
    )
}
```

---

## Compiling Wire

### 1. Generate Wire Code

Navigate to the directory containing `wire.go`:

```bash
cd /Users/duongphamthaibinh/Downloads/SourceCode/design/beautiful/golang/auth-service/src/applications
```

Run Wire:

```bash
wire
```

Expected output:

```
wire: auth-service/src/applications: wrote /Users/.../auth-service/src/applications/wire_gen.go
```

### 2. Verify Generated Code

Check `wire_gen.go` was created:

```bash
ls -la wire_gen.go
```

The file should contain:

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package applications

// ... generated initialization code
```

### 3. Use the Injector

In your `main.go` or startup code:

```go
package main

import (
    "auth-service/src/applications"
    "auth-service/src/infrastructure/config"
    "backend-core/database"
    "backend-core/logging"
)

func main() {
    // Load config
    cfg := config.LoadConfig()

    // Initialize dependencies
    logger := logging.NewLogger(cfg.LogLevel)
    db := database.NewPostgresDB(cfg.Database)
    brokers := []string{cfg.Kafka.Brokers}

    // Use Wire-generated injector
    router := applications.InitializeAuthService(cfg, db, brokers, logger)

    // Start server
    router.Run(":8085")
}
```

### 4. Automate with go:generate

Add this comment to `wire.go`:

```go
//go:generate wire
```

Then regenerate with:

```bash
go generate ./src/applications
```

---

## Creating Providers

### Step 1: Define Provider Function

Create a provider in `src/applications/providers/`:

```go
// src/applications/providers/my_providers.go
package providers

import "auth-service/src/domain/services"

// NewUserServiceProvider creates a user domain service
func NewUserServiceProvider(
    userRepo repositories.UserRepository,
    logger *logging.Logger,
) services.UserDomainService {
    return services.NewUserDomainService(userRepo, logger)
}
```

### Step 2: Add to Wire Build

Update `wire.go`:

```go
func InitializeAuthService(...) *gin.Engine {
    wire.Build(
        // ... existing providers
        providers.NewUserServiceProvider, // Add new provider
    )
    return &gin.Engine{}
}
```

### Step 3: Regenerate

```bash
cd src/applications
wire
```

### Step 4: Verify

Check `wire_gen.go` includes your provider in the initialization chain.

---

## Compiling Wire - Complete Workflow

### Method 1: Manual Compilation

```bash
# 1. Navigate to wire.go directory
cd /Users/duongphamthaibinh/Downloads/SourceCode/design/beautiful/golang/auth-service/src/applications

# 2. Run wire
wire

# 3. Verify output
cat wire_gen.go | head -20

# 4. Build project
cd ../..
go build -o auth-service cmd/http/main.go
```

### Method 2: Using go:generate

```bash
# 1. Add to wire.go (if not present)
//go:generate wire

# 2. Run from project root
go generate ./src/applications

# 3. Build
go build -o auth-service cmd/http/main.go
```

### Method 3: Makefile Integration

Create `Makefile`:

```makefile
.PHONY: wire
wire:
	@echo "Generating Wire code..."
	cd src/applications && wire
	@echo "✅ Wire code generated"

.PHONY: build
build: wire
	@echo "Building auth-service..."
	go build -o auth-service cmd/http/main.go
	@echo "✅ Build complete"

.PHONY: run
run: build
	./auth-service
```

Usage:

```bash
make wire   # Generate Wire code
make build  # Generate Wire + Build
make run    # Generate + Build + Run
```

---

## Troubleshooting

### Problem 1: `wire: command not found`

**Solution**: Install Wire CLI:

```bash
go install github.com/google/wire/cmd/wire@latest
export PATH=$PATH:$(go env GOPATH)/bin
```

### Problem 2: `no such file or directory: wire_gen.go`

**Cause**: Wire hasn't been run yet.

**Solution**: Run Wire to generate the file:

```bash
cd src/applications
wire
```

### Problem 3: `unused provider`

**Error**:

```
wire: /path/to/wire.go:XX:X: inject InitializeAuthService: unused provider "ProviderName"
```

**Cause**: Provider is listed but its output isn't used by any other provider or the injector's return type.

**Solution**: Either:

- Use the provider's output somewhere
- Remove it from `wire.Build()`

### Problem 4: `no provider found for TYPE`

**Error**:

```
wire: /path/to/wire.go:XX:X: no provider found for TYPE
```

**Cause**: Missing a provider for a required dependency.

**Solution**: Add the missing provider to `wire.Build()`.

### Problem 5: Build tags mismatch

**Error**:

```
wire: cannot use wireinject build tag
```

**Solution**: Ensure `wire.go` has:

```go
//go:build wireinject
// +build wireinject
```

And `wire_gen.go` (if manually created) has:

```go
//go:build !wireinject
// +build !wireinject
```

### Problem 6: Circular dependency

**Error**:

```
wire: cycle detected
```

**Cause**: Provider A depends on B, and B depends on A.

**Solution**: Refactor to break the cycle:

- Use interfaces
- Introduce a mediator
- Restructure dependencies

---

## Best Practices

### 1. Organize Providers by Layer

```
providers/
├── repository_providers.go    # Data layer
├── service_providers.go        # Business logic layer
├── handler_providers.go        # Presentation layer
└── middleware_providers.go     # Cross-cutting concerns
```

### 2. Use Provider Sets for Related Dependencies

```go
// Infrastructure provider set
var InfraProviderSet = wire.NewSet(
    DatabaseProvider,
    CacheProvider,
    LoggerProvider,
)

// Repository provider set
var RepositoryProviderSet = wire.NewSet(
    UserRepositoryProvider,
    RoleRepositoryProvider,
)

// In wire.go
wire.Build(
    InfraProviderSet,
    RepositoryProviderSet,
    // ... other providers
)
```

### 3. Keep Providers Simple

```go
// GOOD: Simple, single responsibility
func UserRepositoryProvider(db database.Database) repositories.UserRepository {
    return postgres.NewPostgresUserRepository(db)
}

// BAD: Complex logic in provider
func UserRepositoryProvider(db database.Database) repositories.UserRepository {
    repo := postgres.NewPostgresUserRepository(db)
    repo.SomeConfig = "value"
    repo.Initialize()
    // ... more logic
    return repo
}
```

### 4. Use Interfaces for Flexibility

```go
// Define interface
type UserRepository interface {
    FindByID(id string) (*domain.User, error)
}

// Provider returns interface
func UserRepositoryProvider(db database.Database) UserRepository {
    return postgres.NewPostgresUserRepository(db)
}
```

### 5. Add Comments to Providers

```go
// UserApplicationServiceProvider creates a user application service
// with all required dependencies including repository, cache, and telemetry
func UserApplicationServiceProvider(
    userRepo repositories.UserRepository,
    userCache repositories.UserCache,
    logger *logging.Logger,
    telemetry *telemetry.SimpleTelemetry,
    metrics *telemetry.BusinessMetrics,
) *services.UserApplicationService {
    return services.NewUserApplicationService(
        userRepo,
        userCache,
        logger,
        telemetry,
        metrics,
    )
}
```

### 6. Git Ignore wire_gen.go

Add to `.gitignore`:

```
# Wire generated files
wire_gen.go
**/wire_gen.go
```

**Why?**: Generated code should not be committed. Developers run `wire` locally.

**Alternative approach**: Some teams commit `wire_gen.go` to avoid build issues. Choose based on your team's preference.

### 7. Automate Wire Generation in CI/CD

```yaml
# .github/workflows/build.yml
- name: Generate Wire code
  run: |
    go install github.com/google/wire/cmd/wire@latest
    cd src/applications && wire

- name: Build
  run: go build -o auth-service cmd/http/main.go
```

---

## Comparison: Wire vs ServiceFactory

The `auth-service` currently uses `ServiceFactory` (manual DI). Here's a comparison:

### Current Approach: ServiceFactory

**File**: `src/applications/service_factory.go`

```go
func (f *ServiceFactory) CreateRouter(brokers []string) *gin.Engine {
    // Manually create each dependency
    userRepo := providers.UserRepositoryProvider(f.db, f.logger)
    userCache := providers.UserCacheProvider(f.db, f.logger)
    userService := providers.UserApplicationServiceProvider(
        userRepo,
        userCache,
        f.logger,
        simpleTelemetry,
        businessMetrics,
    )
    // ... many more manual calls
    return ginRouter
}
```

**Pros**:

- ✅ Simple to understand
- ✅ Easy to debug
- ✅ Direct control
- ✅ No code generation step

**Cons**:

- ❌ Manual updates when dependencies change
- ❌ Easy to miss a dependency
- ❌ Verbose for large projects
- ❌ No compile-time validation of dependency graph

### Wire Approach

**File**: `src/applications/wire.go` + generated `wire_gen.go`

```go
func InitializeAuthService(...) *gin.Engine {
    wire.Build(
        providers.UserRepositoryProvider,
        providers.UserCacheProvider,
        providers.UserApplicationServiceProvider,
        // ... just list providers
    )
    return &gin.Engine{}
}
```

**Pros**:

- ✅ Automatic dependency resolution
- ✅ Compile-time validation
- ✅ Less boilerplate
- ✅ Easy to add/remove providers

**Cons**:

- ❌ Extra build step (running `wire`)
- ❌ Learning curve for Wire syntax
- ❌ Generated code to maintain
- ❌ Slightly harder to debug (need to look at wire_gen.go)

### Recommendation

**For this project**: Continue using `ServiceFactory` for now because:

1. The manual approach is working well
2. The project is not large enough to benefit significantly from Wire
3. Team familiarity with manual DI

**Consider Wire when**:

- Project grows to 50+ dependencies
- Frequent dependency structure changes
- New team members need clear dependency documentation
- Wanting to enforce architectural boundaries

---

## Quick Reference

### Essential Commands

```bash
# Install Wire
go install github.com/google/wire/cmd/wire@latest

# Generate Wire code
cd src/applications && wire

# Generate using go generate
go generate ./src/applications

# Build project after Wire generation
go build -o auth-service cmd/http/main.go
```

### File Structure

```
src/applications/
├── wire.go           # Wire definitions (edit this)
├── wire_gen.go       # Generated code (don't edit)
├── service_factory.go # Manual DI alternative
└── providers/        # Provider functions
```

### Provider Template

```go
package providers

// [Name]Provider creates a [description]
func [Name]Provider(
    dep1 Dependency1,
    dep2 Dependency2,
) ReturnType {
    return New[Name](dep1, dep2)
}
```

### Injector Template

```go
//go:build wireinject
// +build wireinject

package applications

import "github.com/google/wire"

func Initialize[Name](...params) *Result {
    wire.Build(
        Provider1,
        Provider2,
        // ...
    )
    return &Result{}
}
```

---

## Additional Resources

- **Official Wire Documentation**: https://github.com/google/wire/blob/main/docs/guide.md
- **Wire Tutorial**: https://github.com/google/wire/blob/main/_tutorial/README.md
- **Wire Best Practices**: https://github.com/google/wire/blob/main/docs/best-practices.md
- **Go Blog - Wire**: https://go.dev/blog/wire

---

## Summary

Google Wire is a powerful compile-time dependency injection tool for Go that:

1. **Generates code** to wire dependencies automatically
2. **Validates** dependency graphs at compile time
3. **Reduces boilerplate** compared to manual DI
4. **Maintains type safety** with no runtime overhead

**For auth-service**:

- Wire is configured and ready to use
- Run `wire` in `src/applications` to generate code
- Use `InitializeAuthService()` in your main.go
- Alternatively, continue using `ServiceFactory` (current approach)

Choose Wire when your project's complexity justifies the added build step and learning curve.
